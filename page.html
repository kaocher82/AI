<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI GitHub Agent Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">
    <div class="w-full max-w-4xl mx-auto p-8 bg-gray-800 rounded-2xl shadow-2xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">AI GitHub Agent Manager</h1>
            <p class="text-gray-400 mt-2">Your AI-powered assistant for managing GitHub repositories.</p>
        </div>

        <div class="space-y-6">
            <div>
                <label for="repoUrl" class="block text-sm font-medium text-gray-300 mb-2">GitHub Repository URL</label>
                <input type="text" id="repoUrl" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., https://github.com/kaocher82/my-awesome-project">
            </div>

            <div>
                <label for="githubToken" class="block text-sm font-medium text-gray-300 mb-2">GitHub Personal Access Token</label>
                <input type="password" id="githubToken" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter your GitHub token">
            </div>

            <div>
                <label for="geminiApiKey" class="block text-sm font-medium text-gray-300 mb-2">Gemini API Key (Optional)</label>
                <input type="password" id="geminiApiKey" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Leave empty if running in a managed environment">
            </div>

            <div>
                <label for="command" class="block text-sm font-medium text-gray-300 mb-2">AI Command</label>
                <textarea id="command" rows="4" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., Create a new file named 'index.js' with a simple console.log statement."></textarea>
            </div>

            <button id="executeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">
                Execute Command
            </button>
        </div>

        <div id="result" class="mt-8 p-6 bg-gray-900 rounded-lg hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Results</h2>
            <div id="loader" class="loader mx-auto hidden"></div>
            <pre id="output" class="text-gray-300 whitespace-pre-wrap text-sm"></pre>
        </div>
    </div>

    <script>
        const executeBtn = document.getElementById('executeBtn');
        const repoUrlInput = document.getElementById('repoUrl');
        const githubTokenInput = document.getElementById('githubToken');
        const geminiApiKeyInput = document.getElementById('geminiApiKey');
        const commandInput = document.getElementById('command');
        const resultDiv = document.getElementById('result');
        const outputPre = document.getElementById('output');
        const loader = document.getElementById('loader');

        executeBtn.addEventListener('click', async () => {
            const repoUrl = repoUrlInput.value.trim();
            const token = githubTokenInput.value.trim();
            const geminiApiKey = geminiApiKeyInput.value.trim();
            const command = commandInput.value.trim();

            if (!repoUrl || !token || !command) {
                outputPre.textContent = 'Please fill in all required fields: GitHub Repository URL, GitHub Personal Access Token, and AI Command.';
                resultDiv.classList.remove('hidden');
                loader.classList.add('hidden');
                return;
            }

            resultDiv.classList.remove('hidden');
            loader.classList.remove('hidden');
            outputPre.textContent = '';

            try {
                const [owner, repo] = new URL(repoUrl).pathname.slice(1).split('/');

                // Step 1: Get repository file structure
                const files = await getRepoFiles(owner, repo, token);
                const fileStructure = files.map(file => file.path).join('\n');

                // Step 2: Call Gemini API
                const aiResponse = await callGeminiApi(command, fileStructure, owner, repo, geminiApiKey);
                 outputPre.textContent += "AI Response:\n" + JSON.stringify(aiResponse, null, 2) + "\n\n";


                // Step 3: Execute GitHub actions
                if (aiResponse.actions && Array.isArray(aiResponse.actions)) {
                    for (const action of aiResponse.actions) {
                        await executeGithubAction(owner, repo, token, action);
                    }
                } else {
                     outputPre.textContent += "No actions to perform or invalid format.\n";
                }


            } catch (error) {
                console.error('Error:', error);
                outputPre.textContent = `An error occurred: ${error.message}`;
            } finally {
                loader.classList.add('hidden');
            }
        });

        async function getRepoFiles(owner, repo, token) {
            const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/main?recursive=1`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.statusText}`);
            }
            const data = await response.json();
            return data.tree.filter(node => node.type === 'blob');
        }

        async function callGeminiApi(command, fileStructure, owner, repo, providedApiKey) {
            const apiKey = providedApiKey || ""; // Use provided key or default to environment-managed
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const systemPrompt = `You are an expert AI assistant that helps manage GitHub repositories. Based on the user's command and the current repository file structure, you will determine the necessary actions to perform.

The possible actions are: 'CREATE', 'UPDATE', 'DELETE', or 'READ'.

Your response MUST be a JSON object with a key "actions" which is an array of action objects.
Each action object should have the following properties:
- "action": The type of action ('CREATE', 'UPDATE', 'DELETE', 'READ').
- "filepath": The full path of the file to be acted upon.
- "content": The content of the file (for 'CREATE' and 'UPDATE' actions). Base64 encode the content. For other actions, this can be an empty string.
- "commitMessage": A descriptive commit message for the action.

Example response for creating a file:
{
  "actions": [
    {
      "action": "CREATE",
      "filepath": "src/new-feature.js",
      "content": "Y29uc29sZS5sb2coJ0hlbGxvLCB3b3JsZCEnKTs=",
      "commitMessage": "feat: add new feature file"
    }
  ]
}

Current repository: ${owner}/${repo}
File structure:
${fileStructure}
`;
            const userQuery = `User command: "${command}"`;

             const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                 generationConfig: {
                    responseMimeType: "application/json",
                }
            };


            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.statusText}`);
            }

            const result = await response.json();
            const text = result.candidates[0].content.parts[0].text;
            return JSON.parse(text);
        }

       async function executeGithubAction(owner, repo, token, action) {
            outputPre.textContent += `Executing action: ${action.action} on ${action.filepath}\n`;

            let url, body;

            const headers = {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };

            switch (action.action) {
                case 'CREATE':
                case 'UPDATE':
                    // To update a file, you need its SHA blob.
                    let sha;
                    if (action.action === 'UPDATE') {
                        try {
                            const fileResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                            if (fileResponse.ok) {
                                const fileData = await fileResponse.json();
                                sha = fileData.sha;
                            } else {
                                throw new Error('File not found for update.');
                            }
                        } catch (e) {
                            outputPre.textContent += `Could not get SHA for ${action.filepath}. Treating as CREATE.\n`;
                        }
                    }

                    url = `https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`;
                    body = {
                        message: action.commitMessage,
                        content: action.content, // Assumes content is already base64 encoded by Gemini
                        sha: sha
                    };

                    const response = await fetch(url, {
                        method: 'PUT',
                        headers,
                        body: JSON.stringify(body)
                    });

                    if (response.ok) {
                        outputPre.textContent += `Successfully ${action.action === 'CREATE' ? 'created' : 'updated'} ${action.filepath}\n`;
                    } else {
                         const errorData = await response.json();
                        outputPre.textContent += `Failed to ${action.action === 'CREATE' ? 'created' : 'updated'} ${action.filepath}: ${errorData.message}\n`;
                    }

                    break;

                case 'DELETE':
                     try {
                        const fileResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                        if (!fileResponse.ok) throw new Error('File not found');
                        const fileData = await fileResponse.json();


                        url = `https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`;
                        body = {
                            message: action.commitMessage,
                            sha: fileData.sha
                        };

                        const deleteResponse = await fetch(url, {
                            method: 'DELETE',
                            headers,
                            body: JSON.stringify(body)
                        });

                        if (deleteResponse.ok) {
                            outputPre.textContent += `Successfully deleted ${action.filepath}\n`;
                        } else {
                             const errorData = await deleteResponse.json();
                            outputPre.textContent += `Failed to delete ${action.filepath}: ${errorData.message}\n`;
                        }
                    } catch(e){
                         outputPre.textContent += `Error during delete pre-fetch: ${e.message}\n`;
                    }
                    break;

                 case 'READ':
                    try {
                        const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                         if (!response.ok) throw new Error('File not found');
                        const data = await response.json();
                        const content = atob(data.content);
                        outputPre.textContent += `Content of ${action.filepath}:\n\n${content}\n\n`;
                    } catch (e) {
                        outputPre.textContent += `Failed to read file ${action.filepath}: ${e.message}\n`;
                    }
                    break;
                default:
                    outputPre.textContent += `Unknown action: ${action.action}\n`;
            }
        }

    </script>
</body>
</html>

